use chrono::prelude::*;
use std::collections::HashSet;

use num_traits::FromPrimitive;

use crate::{year_group_range, YearMonth};

#[cfg(test)]
use mockall::automock;

/// Trait that can be implemented to create your own date constraints.
#[cfg_attr(test, automock)]
pub trait HasDateConstraints {
    /// Returns true if the given date is forbidden.
    fn is_day_forbidden(&self, date: &NaiveDate) -> bool;

    /// Returns true if the entire month described by year_month_info is forbidden.
    fn is_month_forbidden(&self, year_month_info: &YearMonth) -> bool;

    /// Returns true if the entire given year is forbidden.
    fn is_year_forbidden(&self, year: i32) -> bool;

    /// Returns true if the entire group of years including the given year is forbidden.
    /// A group of years are inclusive intervals [1980, 1999], [2000, 2019], [2020, 2039], ...
    fn is_year_group_forbidden(&self, year: i32) -> bool;
}

/// Date constraints configuration
#[derive(Default, Debug, Clone, Builder)]
#[builder(setter(strip_option))]
#[builder(default)]
#[builder(build_fn(validate = "Self::validate"))]
pub struct DateConstraints {
    /// inclusive minimal date constraint
    /// the earliest date that can be selected
    min_date: Option<NaiveDate>,

    /// inclusive maximal date constraint
    /// the latest date that can be selected
    max_date: Option<NaiveDate>,

    /// disabled weekdays, that should not be selectable
    disabled_weekdays: HashSet<Weekday>,

    /// entire completely disabled months in every year
    disabled_months: HashSet<Month>,

    /// entire completely disabled years
    disabled_years: HashSet<i32>,

    /// disabled monthly periodically repeating dates, so it is just a day number
    /// starting from 1 for the first day of the month
    /// if unique dates in a certain year should not be selectable use `disabled_unique_dates`
    disabled_monthly_dates: HashSet<u32>,

    /// disabled yearly periodically repeating dates that should not be selectable,
    /// if unique dates in a certain year should not be selectable use `disabled_unique_dates`
    /// it is a `Vec` since we need to iterate over it anyway, since we hae no MonthDay type
    disabled_yearly_dates: Vec<NaiveDate>,

    /// disabled unique dates with a specific year, month and day that should not be selectable,
    /// if some periodically repeated dates should not be selectable use the correct option
    disabled_unique_dates: HashSet<NaiveDate>,
}

impl DateConstraintsBuilder {
    fn validate(&self) -> Result<(), String> {
        match (self.min_date, self.max_date) {
            (Some(min_date), Some(max_date)) => {
                if min_date > max_date {
                    return Err("min_date must be earlier or exactly at max_date".into());
                }
            }
            (_, _) => {}
        }
        Ok(())
    }
}

// TODO: find out how to place #[derive(Debug, Clone)] on the structure generated by automock
// this is a temporary workaround for tests
cfg_if::cfg_if! {
    if #[cfg(test)] {
        impl Clone for MockHasDateConstraints {
            fn clone(&self) -> Self {
                Self::new()
            }
        }

        use core::fmt;
        impl fmt::Debug for MockHasDateConstraints {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.debug_struct("MockHasDateConstraints").finish()
            }
        }
    }
}

impl HasDateConstraints for DateConstraints {
    fn is_day_forbidden(&self, date: &NaiveDate) -> bool {
        self.min_date.map_or(false, |min_date| &min_date > date)
            || self.max_date.map_or(false, |max_date| &max_date < date)
            || self.disabled_weekdays.contains(&date.weekday())
            || self
                .disabled_months
                .contains(&Month::from_u32(date.month()).unwrap())
            || self.disabled_years.contains(&date.year())
            || self.disabled_unique_dates.contains(&date)
            || self.disabled_monthly_dates.contains(&date.day())
            || self
                .disabled_yearly_dates
                .iter()
                .any(|disabled| disabled.day() == date.day() && disabled.month() == date.month())
    }

    fn is_month_forbidden(&self, year_month_info: &YearMonth) -> bool {
        self.disabled_years.contains(&year_month_info.year)
            || self.disabled_months.contains(&year_month_info.month)
            || year_month_info
                .first_day_of_month()
                .iter_days()
                .take_while(|date| date.month() == year_month_info.month.number_from_month())
                .all(|date| self.is_day_forbidden(&date))
    }

    fn is_year_forbidden(&self, year: i32) -> bool {
        self.disabled_years.contains(&year)
            || (Month::January.number_from_month()..=Month::December.number_from_month()).all(
                |month| {
                    self.is_month_forbidden(&YearMonth {
                        year,
                        month: Month::from_u32(month).unwrap(),
                    })
                },
            )
    }

    fn is_year_group_forbidden(&self, year: i32) -> bool {
        year_group_range(year).all(|year| self.is_year_forbidden(year))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::Duration;
    use proptest::prelude::*;

    proptest! {
        #[test]
        fn is_day_forbidden_default_no_bounds(day in 1..365*5000i32) {
            let date = NaiveDate::from_num_days_from_ce(day);
            assert!(!DateConstraints::default().is_day_forbidden(&date))
        }
    }

    proptest! {
        #[test]
        fn is_month_forbidden_default_no_bounds(year in 1..5000i32, month_num in 1..=12u32) {
            let month = Month::from_u32(month_num).unwrap();
            let year_month_info = YearMonth {
                year,
                month,
            };
            assert!(!DateConstraints::default().is_month_forbidden(&year_month_info))
        }
    }

    proptest! {
        #[test]
        fn is_year_forbidden_default_no_bounds(year in 1..5000i32) {
            assert!(!DateConstraints::default().is_year_forbidden(year))
        }
    }

    #[test]
    fn picker_config_min_date_greater_than_max_date() {
        let date = NaiveDate::from_ymd(2020, 10, 15);
        let config = DateConstraintsBuilder::default()
            .min_date(date.clone())
            .max_date(date.clone() - Duration::days(1))
            .build();
        assert!(config.is_err());
        assert_eq!(
            config.err(),
            Some("min_date must be earlier or exactly at max_date".into())
        );
    }

    #[test]
    fn picker_config_min_date_equals_max_date() {
        let date = NaiveDate::from_ymd(2020, 10, 15);
        let config = DateConstraintsBuilder::default()
            .min_date(date.clone())
            .max_date(date.clone())
            .build();
        assert!(config.is_ok());
    }

    #[test]
    fn is_day_forbidden_at_min_date_allowed() {
        let date = NaiveDate::from_ymd(2020, 10, 15);
        let config = DateConstraintsBuilder::default()
            .min_date(date.clone())
            .build()
            .unwrap();
        assert!(!config.is_day_forbidden(&date))
    }

    #[test]
    fn is_day_forbidden_before_min_date_not_allowed() {
        let date = NaiveDate::from_ymd(2020, 10, 15);
        let config = DateConstraintsBuilder::default()
            .min_date(date.clone())
            .build()
            .unwrap();
        assert!(config.is_day_forbidden(&(date - Duration::days(1))))
    }

    #[test]
    fn is_day_forbidden_at_max_date_allowed() {
        let date = NaiveDate::from_ymd(2020, 10, 15);
        let config = DateConstraintsBuilder::default()
            .max_date(date.clone())
            .build()
            .unwrap();
        assert!(!config.is_day_forbidden(&date))
    }

    #[test]
    fn is_day_forbidden_after_max_date_not_allowed() {
        let date = NaiveDate::from_ymd(2020, 10, 15);
        let config = DateConstraintsBuilder::default()
            .max_date(date.clone())
            .build()
            .unwrap();
        assert!(config.is_day_forbidden(&(date + Duration::days(1))))
    }

    proptest! {
        #[test]
        fn is_day_forbidden_disabled_weekday_not_allowed(weekday in 0..7u8, year in 1..5000i32, iso_week in 1..52u32) {
            let disabled_weekday = Weekday::from_u8(weekday).unwrap();
            let date = NaiveDate::from_isoywd(year, iso_week, disabled_weekday);
            let config = DateConstraintsBuilder::default()
                .disabled_weekdays([disabled_weekday].iter().cloned().collect())
                .build()
                .unwrap();
            assert!(config.is_day_forbidden(&date));
        }
    }

    proptest! {
        #[test]
        fn is_day_forbidden_disabled_month_not_allowed(month_num in 1..=12u32, year in 1..5000i32, day in 1..=28u32) {
            let config = DateConstraintsBuilder::default()
                .disabled_months([Month::from_u32(month_num).unwrap()].iter().cloned().collect())
                .build()
                .unwrap();
            assert!(config.is_day_forbidden(&NaiveDate::from_ymd(year, month_num, day)))
        }
    }

    proptest! {
        #[test]
        fn is_day_forbidden_disabled_year_not_allowed(month_num in 1..=12u32, year in 1..5000i32, day in 1..=28u32) {
            let config = DateConstraintsBuilder::default()
                .disabled_years([year].iter().cloned().collect())
                .build()
                .unwrap();
            assert!(config.is_day_forbidden(&NaiveDate::from_ymd(year, month_num, day)))
        }
    }

    #[test]
    fn is_day_forbidden_disabled_unique_dates_not_allowed() {
        let date = NaiveDate::from_ymd(2020, 1, 16);
        let config = DateConstraintsBuilder::default()
            .disabled_unique_dates([date].iter().cloned().collect())
            .build()
            .unwrap();
        assert!(config.is_day_forbidden(&date))
    }

    #[test]
    fn is_day_forbidden_disabled_unique_dates_after_a_year_allowed() {
        let date = NaiveDate::from_ymd(2020, 1, 16);
        let config = DateConstraintsBuilder::default()
            .disabled_unique_dates([date].iter().cloned().collect())
            .build()
            .unwrap();
        assert!(!config.is_day_forbidden(&NaiveDate::from_ymd(2021, 1, 16)))
    }

    proptest! {
        #[test]
        fn is_day_forbidden_disabled_yearly_dates_not_allowed(year_in_disabled in 1..5000i32, year_in_input in 1..5000i32, month in 1..=12u32, day in 1..=28u32) {
            let disabled_yearly_date = NaiveDate::from_ymd(year_in_disabled, month, day);
            let config = DateConstraintsBuilder::default()
                .disabled_yearly_dates(vec![disabled_yearly_date])
                .build()
                .unwrap();
            assert!(config.is_day_forbidden(&NaiveDate::from_ymd(year_in_input, month, day)))
        }
    }

    proptest! {
        #[test]
        fn is_day_forbidden_disabled_monthly_dates_not_allowed(year in 1..5000i32, month in 1..=12u32, day in 1..=28u32) {
            let config = DateConstraintsBuilder::default()
                .disabled_monthly_dates([day].iter().cloned().collect())
                .build()
                .unwrap();
            assert!(config.is_day_forbidden(&NaiveDate::from_ymd(year, month, day)))
        }
    }

    proptest! {
        #[test]
        fn is_month_forbidden_disabled_months_not_allowed(year in 1..5000i32, month_num in 1..=12u32) {
            let month = Month::from_u32(month_num).unwrap();
            let config = DateConstraintsBuilder::default()
                .disabled_months([month].iter().cloned().collect())
                .build()
                .unwrap();
            assert!(config.is_month_forbidden(&YearMonth {
                year,
                month
            }))
        }
    }

    proptest! {
        #[test]
        fn is_month_forbidden_disabled_years_not_allowed(year in 1..5000i32, month_num in 1..=12u32) {
            let month = Month::from_u32(month_num).unwrap();
            let config = DateConstraintsBuilder::default()
                .disabled_years([year].iter().cloned().collect())
                .build()
                .unwrap();
            assert!(config.is_month_forbidden(&YearMonth {
                year,
                month
            }))
        }
    }

    proptest! {
        #[test]
        fn is_year_forbidden_disabled_years_not_allowed(year in 1..5000i32) {
            let config = DateConstraintsBuilder::default()
                .disabled_years([year].iter().cloned().collect())
                .build()
                .unwrap();
            assert!(config.is_year_forbidden(year))
        }
    }
}
